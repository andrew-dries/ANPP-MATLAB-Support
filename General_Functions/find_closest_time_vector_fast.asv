function [index1, index2] = find_closest_time_vector_fast(time1, time2)
%This function will take two time indecies of different lengths and return
%two index vectors that correlate the indecies with the closest times to
%each other

    %*********************************************************************%
    %Initialization
    %*********************************************************************%

    %Initialize index
    

    %Determine min & max for each vector
    min_time_1      = min(time1);
    max_time_1      = max(time1);
    min_time_2      = min(time2);
    max_time_2      = max(time2);

    %Determine time overlaps
    start_time      = max(min_time_1, min_time_2);
    end_time        = min(max_time_1, max_time_2);

    %Determine who has the smaller step size
    step_size_time_1    = median(diff(unique(time1)));
    step_size_time_2    = median(diff(unique(time2)));

    %Determine if time1 or time 2 is the smaller time step
    if(step_size_time_1 <= step_size_time_2)

        %Step size time 1 is smaller, therefore a larger vector
        step_size           = 1;
        small_time          = time2;
        big_time            = time1;
        big_time_min        = min_time_1;
        big_time_max        = max_time_1;
        small_time_min      = min_time_2;
        small_time_max      = max_time_2;
        big_time_max_ind    = length(time1);
        small_index         = zeros(size(time2));
        big_index           = zeros(size(time1));

    else
        
        %Step size time 2 is smaller, therefore a larger vector
        step_size           = 2;
        small_time          = time1;
        big_time            = time2;
        big_time_min        = min_time_2;
        big_time_max        = max_time_2;
        small_time_min      = min_time_1;
        small_time_max      = max_time_1;
        big_time_max_ind    = length(time2);
        small_index         = zeros(size(time1));
        big_index           = zeros(size(time2));

    end

    %Initialize last index to 0
    last_index      = 0;

    %*********************************************************************%
    %Pass through the smaller vector length, and determine the closest time
    %at each iteration
    %*********************************************************************%

    %Determine the starting and stopping indecies
    if(small_time_min >= big_time_max_ind)
        start_ind = 1;
    else
        start_ind   = find(small_time >= big_time_min, 1);
    end
    
    stop_ind    = find(small_time >= big_time_max, 1);

    %Step through
    for i = 1:length(small_time)

        %First, check to see if this small time increment is smaller than
        %the smallest big time value
        if(small_time(i) < big_time_min)
            index(i,1) = last_index + 1;

        %On the first pass engage the find closest time function to grab
        %the first index
        elseif(i == 1)
            
            %Find the index that matches
            index(i,1) = find_closest_time(big_time, small_time(i));

            %If index is 0, revert back to 1
            if(index(i) == 0)
                index(i,1) = 1;
            end

        else

            %On subsequent passes, engage a faster method

            %Save off last index to index temp
            index_temp  = last_index;

            %Grab time delta between current small time, and the last saved
            %index for big time
            delta1      = abs(small_time(i) - big_time(index_temp));

            %Increment index temp
            index_temp  = index_temp + 1;

            %Check that we haven't maxed out
            if(index_temp > length(time1))
                index_temp = index_temp - 1;
            end

            %Grab the time between current small time, and the next index
            %of big time
            delta2      = abs(small_time(i) - big_time(index_temp));

            while(delta2 <= delta1)

                %Grab time delta between current small time, and the last saved
                %index for big time
                delta1      = abs(small_time(i) - big_time(index_temp));
    
                %Increment index temp
                index_temp  = index_temp + 1;

                %Check that index doesn't exceed max
                if(index_temp > length(time1))
                    index(i,1) = index_temp - 1;
                    break;
                end
    
                %Grab the time between current small time, and the next index
                %of big time
                delta2      = abs(small_time(i) - big_time(index_temp));

            end
    
            %Save index
            index(i,1) = index_temp - 1;

        end

        %Record the last used index
        last_index  = index(i);

    end

end

